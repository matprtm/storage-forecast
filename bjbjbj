# Storage Forecast

# Membaca data dan memasukkan di Dataframe
sh = gc.open_by_key('15EIMxmbWRjT_th-pw5Kbido0dvQUTtSUyPvYboGpfdE')

worksheet = sh.worksheet("TEST 3")
rows = worksheet.get_all_values()

df_usage = pd.DataFrame.from_records(rows[1:],columns=rows[0])
df_usage.head(4)

df_usage['ds']= pd.to_datetime(df_usage['ds'])
df_usage['usage - actual'] = pd.to_numeric(df_usage['usage - actual'])

df_usage.rename(columns={'usage - actual': 'usage - actual'}, inplace=True)

usage = df_usage[['ds','usage - actual']]

usage = usage[(usage['ds'] >= "2023-01-01") &
                            (usage['ds'] <= "2026-01-01")]

plt.plot(usage.ds, usage['usage - actual'])
plt.title('Usage - Data Actual')
plt.xlabel('Periode')
plt.ylabel('Usage (GB)')
plt.legend()

## Prophet

df_usage = usage

df_usage.rename(columns={'usage - actual': 'y'}, inplace=True)
df_usage.tail()

df_usage.reset_index(inplace=True)
df_usage = df_usage.drop(['index'], axis=1)

pd.concat([df_usage.head(1), df_usage.tail(1)])

print(f'data: {len(df_usage)} rows')
test_split = 0.1
train_usage, test_usage = split_data(df_usage, test_split)

### Train & Test

plt.plot(train_usage.ds, train_usage.y, color = 'black', marker = 'o', ms = 9, label = 'Train')
plt.plot(test_usage.ds, test_usage.y, marker = 'o', ms = 9, label = 'Test')
plt.legend(loc = 'best')
plt.title(f'Usage (train = {len(train_usage)} and test = {len(test_usage)})')
plt.xlabel("Periode", fontsize=12)
plt.ylabel("Usage (GB)", fontsize=12)
plt.show()

#### Seasonality Mode Detection

def detect_seasonality_mode(df, col='y'):
    if (df[col] <= 0).any():
        return "additive"  # multiplicative gak cocok buat nilai <= 0

    mean_y = df[col].mean()
    std_y = df[col].std()
    cv = std_y / mean_y

    if cv > 0.2:  # threshold bisa disesuaikan
        # cek apakah variasi musiman proporsional terhadap level
        df['log_y'] = np.log(df[col])
        model = LinearRegression().fit(np.arange(len(df)).reshape(-1,1), df['log_y'])
        residuals = df['log_y'] - model.predict(np.arange(len(df)).reshape(-1,1))
        ratio = np.std(residuals) / np.std(df['log_y'])
        return "multiplicative" if ratio < 0.8 else "additive"
    else:
        return "additive"

#### Automation Tuning

# Parameter Grid
param_grid = {
    'changepoint_prior_scale': [0.001, 0.01, 0.1],
    'weekly_seasonality': [True, False],
    'daily_seasonality': [True, False],
    'changepoint_range': [0.7, 0.8, 0.9]
}

# Generate all combinations
all_params = [dict(zip(param_grid.keys(), v)) for v in itertools.product(*param_grid.values())]

best_mape = float("inf")
best_params = None
results = []

# Threshold
THRESHOLD = 10.0  # stop kalau MAPE < 10%

for i, params in enumerate(all_params, 1):
    model = Prophet(**params, yearly_seasonality=True, seasonality_mode=detect_seasonality_mode(train_usage))
    model.fit(train_usage)

    future = model.make_future_dataframe(periods=len(test_usage))
    forecast = model.predict(future)

    predictions=forecast.iloc[-len(test_usage):]['yhat']

    y_true = test_usage['y'].values
    y_pred = forecast[-len(test_usage):]['yhat'].values
    test_usage['e'] = test_usage.y - predictions
    rmse = np.sqrt(np.mean(test_usage.e**2)).round(2)
    mape = np.round(np.mean(np.abs(100*test_usage.e/test_usage.y)))

    results.append((params, mape))

    # Update best
    if mape < best_mape:
        best_mape = mape
        best_params = params

    # Auto-stop kalau sudah di bawah threshold
    # if mape < THRESHOLD:
    if mape < THRESHOLD and mape == best_mape:
        break

print('RMSE =', rmse)
print('MAPE =', best_mape, '%')
print('Tuning =', best_params)

### Result

ax=forecast.plot(x='ds',y='yhat',label='Predictons', color = "dodgerblue", legend=True,figsize=(14,8))
test_usage.plot(x='ds',y='y',label='True Test Data',legend=True,
                     ax=ax,xlim=(test_usage['ds'].min(),test_usage['ds'].max()))

# ax = fig.add_subplot(111)
ax.set_title("Usage : Actual x Prediction", fontsize=16)
ax.set_xlabel("Periode", fontsize=12)
ax.set_ylabel("Bandwidth (Mbps)", fontsize=12)

### Mode Prophet Forecasting

# fit entire dataset - Automation
model=Prophet(**best_params
              )
model.fit(df_usage)
#placehoer to future predictions
future=model.make_future_dataframe(periods=3000,freq='D')
forecast_usage=model.predict(future)



import matplotlib.pyplot as plt
pd.plotting.register_matplotlib_converters()

model.plot(forecast_usage,figsize=(14,8));
plt.xlim(df_usage['ds'].min(),'2030-12-31')

### Cek Run Out

forecast_usage = forecast_usage.sort_values('ds').reset_index(drop=True)
capacity = 5031.92
tol = 0.1

threshold = capacity - tol

# Option A: threshold dengan tol
mask = forecast_usage['yhat'] >= threshold
rising = mask & (~mask.shift(1).fillna(False))
if rising.any():
    first = forecast_usage.loc[rising.idxmax(), ['ds','yhat']]
else:
    print("Belum nyentuh (dgn tol).")

# Option B: sama-sama pakai pembulatan 2 desimal (mirip tampilan sheet)
forecast_usage['yhat_round2'] = forecast_usage['yhat'].round(2)
cap_round = round(capacity, 2)
mask2 = forecast_usage['yhat_round2'] >= cap_round
if mask2.any():
    first2 = forecast_usage.loc[mask2.idxmax(), ['ds','yhat','yhat_round2']]

print('Run Out Date :',first['ds'].date())
print('Run Out Value :',round(first['yhat'],2))

## Save Forecasting

df_usage_forecast = forecast_usage[(forecast_usage['ds'] > df_usage['ds'].max())
                                            & (forecast_usage['ds'] <= "2030-12-31")]
df_usage_forecast = df_usage_forecast[['ds', 'yhat','yhat_upper','yhat_lower']]
df_usage_forecast['ds'] = df_usage_forecast['ds'].astype(str)
df_usage_forecast.rename(columns={'ds': 'ds'}, inplace=True)

pd.concat([forecast_in_max_act.head(1),forecast_in_max_act.tail(1)])

forecast_only = df_usage_forecast[['yhat']]
forecast_only.rename(columns={'yhat': 'usage - forecast'}, inplace=True)
pd.concat([forecast_only.head(1),forecast_only.tail(1)])

auth.authenticate_user()
creds, _ = default()
gc = gspread.authorize(creds)
spreadsheet_key = '15EIMxmbWRjT_th-pw5Kbido0dvQUTtSUyPvYboGpfdE'
workbook = gc.open_by_key(spreadsheet_key)
workbook.values_update(
  'Forecast-TEST3!A1',
  params={
      'valueInputOption': 'USER_ENTERED'
  },
  body={
      'values': [forecast_only.columns.values.tolist()] + forecast_only.values.tolist()
  }
)
